<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMake</title>
    <url>/2022/10/31/CMake/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="支持-cmake-最低版本"><a href="#支持-cmake-最低版本" class="headerlink" title="支持 cmake 最低版本"></a>支持 cmake 最低版本</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.23</span>)    <span class="comment"># 最低支持版本</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_VERSION&#125;</span> <span class="keyword">VERSION_LESS</span> <span class="number">3.23</span>)  <span class="comment"># 判断当前版本是否小于</span></span><br><span class="line">    <span class="comment"># 通过 VERSION 设置策略</span></span><br><span class="line">    <span class="keyword">cmake_policy</span>(VERSION <span class="variable">$&#123;CMAKE_MAJOR_VERSION&#125;</span>.<span class="variable">$&#123;CMAKE_MINOR_VERSION&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">cmake_policy</span>(VERSION <span class="number">3.23</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="设置产品信息"><a href="#设置产品信息" class="headerlink" title="设置产品信息"></a>设置产品信息</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span>                       <span class="comment"># 版本号</span></span><br><span class="line">                  DESCRIPTION <span class="string">&quot;Very nice project&quot;</span>   <span class="comment"># 描述</span></span><br><span class="line">                  LANGUAGES CXX)                    <span class="comment"># 支持的开发语言</span></span><br></pre></td></tr></table></figure>

<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><h4 id="生成执行文件"><a href="#生成执行文件" class="headerlink" title="生成执行文件"></a>生成执行文件</h4><p><code>add_executable(demo main.cpp a.cpp a.h)</code></p>
<h4 id="生成库文件"><a href="#生成库文件" class="headerlink" title="生成库文件"></a>生成库文件</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [&lt;source&gt;...])</span><br></pre></td></tr></table></figure>

<p><code>add_library(demo STATIC main.cpp a.cpp a.h)</code></p>
<p>3 种类型<br>SHARED 动态库<br>STATIC 静态库<br>MODULE</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置生成目标需要的头文件搜索路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接生成目标依赖库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; ... &lt;item&gt;... ...)</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置普通变量</span></span><br><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置缓存变量</span></span><br><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">set</span>(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;])</span><br><span class="line"><span class="comment"># 获取环境变量值</span></span><br><span class="line">$ENV&#123;variable_name&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(&lt;GLOBAL                      |</span><br><span class="line">              DIRECTORY [&lt;dir&gt;]           |</span><br><span class="line">              <span class="keyword">TARGET</span>    [&lt;target1&gt; ...]   |</span><br><span class="line">              SOURCE    [&lt;src1&gt; ...]</span><br><span class="line">                        [DIRECTORY &lt;dirs&gt; ...]</span><br><span class="line">                        [TARGET_DIRECTORY &lt;targets&gt; ...] |</span><br><span class="line">              <span class="keyword">INSTALL</span>   [&lt;file1&gt; ...]     |</span><br><span class="line">              <span class="keyword">TEST</span>      [&lt;test1&gt; ...]     |</span><br><span class="line">              CACHE     [&lt;entry1&gt; ...]    &gt;</span><br><span class="line">             [APPEND] [APPEND_STRING]</span><br><span class="line">             PROPERTY &lt;name&gt; [&lt;value1&gt; ...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次设置多个目标</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> TargetName</span><br><span class="line">             PROPERTY CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 一个目标设置多个属性</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(TargetName PROPERTIES</span><br><span class="line">                      CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取属性</span></span><br><span class="line"><span class="keyword">get_property</span>(ResultVariable <span class="keyword">TARGET</span> TargetName PROPERTY CXX_STANDARD)</span><br></pre></td></tr></table></figure>

<h3 id="宏和函数"><a href="#宏和函数" class="headerlink" title="宏和函数"></a>宏和函数</h3><p>宏和函数的区别在于作用域，宏没有作用域</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 宏</span></span><br><span class="line"><span class="keyword">macro</span>(&lt;name&gt; [&lt;arg1&gt; ...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="keyword">function</span>(&lt;name&gt; [&lt;arg1&gt; ...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">cmake_language(CALL &lt;name&gt;)</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件以 <code>.in</code> 后缀</p>
<p>for example, on Version.h.in</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pragma once</span></span><br><span class="line"><span class="comment">#define MY_VERSION_MAJOR @PROJECT_VERSION_MAJOR@</span></span><br><span class="line"><span class="comment">#define MY_VERSION_MINOR @PROJECT_VERSION_MINOR@</span></span><br><span class="line"><span class="comment">#define MY_VERSION_PATCH @PROJECT_VERSION_PATCH@</span></span><br><span class="line"><span class="comment">#define MY_VERSION_TWEAK @PROJECT_VERSION_TWEAK@</span></span><br><span class="line"><span class="comment">#define MY_VERSION &quot;@PROJECT_VERSION@&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">configure_file</span> (</span><br><span class="line"><span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/include/My/Version.h.in&quot;</span></span><br><span class="line"><span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/include/My/Version.h&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assuming the canonical version is listed in a single line</span></span><br><span class="line"><span class="comment"># This would be in several parts if picking up from MAJOR, MINOR, etc.</span></span><br><span class="line"><span class="keyword">set</span>(VERSION_REGEX <span class="string">&quot;#define MY_VERSION[ \t]+\&quot;(.+)\&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># Read in the line containing the version</span></span><br><span class="line"><span class="keyword">file</span>(STRINGS <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/My/Version.hpp&quot;</span></span><br><span class="line">VERSION_STRING REGEX <span class="variable">$&#123;VERSION_REGEX&#125;</span>)</span><br><span class="line"><span class="comment"># Pick out just the version</span></span><br><span class="line"><span class="keyword">string</span>(REGEX REPLACE <span class="variable">$&#123;VERSION_REGEX&#125;</span> <span class="string">&quot;\\1&quot;</span> VERSION_STRING <span class="string">&quot;$&#123;VERSION_STRING&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># Automatically getting PROJECT_VERSION_MAJOR, My_VERSION_MAJOR, etc.</span></span><br><span class="line"><span class="keyword">project</span>(My LANGUAGES CXX VERSION <span class="variable">$&#123;VERSION_STRING&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><code>cmake --build</code> 等价于 <code>make</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake 目录路径</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>windows 系统下 vscode 使用 cmake 注意</p>
<ol>
<li>安装 MinGW 后，需要在安装目录的 bin 目录下修改 mingw32-make.exe，改成 make.exe，否则无法在命令行中直接使用 make 命令</li>
<li>cmake 命令默认不生成 makefile，需要改成 <code>cmake .. -G &quot;Unix Makefiles&quot;</code></li>
</ol>
</li>
<li><p>无法使用 file() 查找 .h?? 头文件列表</p>
</li>
<li><p>不要使用 GLOB 收集文件列表，因为当源文件添加或者删除时，CMakeLists.txt 没有被修改，CMake 重新生产时并不会识别出它们</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2022/10/31/Git/</url>
    <content><![CDATA[<p>git分成3个区<br>工作区 workspace<br>暂存区 staging area<br>本地库 local repository<br>远程库 remote repository<br><img src="/./../pics/git-command.jpg" alt="Git"></p>
<h2 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;myname&quot;</span><br><span class="line">git config --global user.email  &quot;test@gmail.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化当前目录为本地仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化指定目录为本地仓库</span></span><br><span class="line">git init [directory]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝到当前目录</span></span><br><span class="line">git clone [url]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝到指定目录</span></span><br><span class="line">git clone [url] [directory]</span><br></pre></td></tr></table></figure>

<h2 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git add</td>
<td>添加文件到暂存区</td>
</tr>
<tr>
<td>git status</td>
<td>查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr>
<td>git diff</td>
<td>比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td>git commit</td>
<td>提交暂存区到本地仓库。</td>
</tr>
<tr>
<td>git reset</td>
<td>回退版本。</td>
</tr>
<tr>
<td>git rm</td>
<td>将文件从暂存区和工作区中删除。</td>
</tr>
<tr>
<td>git mv</td>
<td>移动或重命名工作区文件。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加多个目录</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加文件夹</span></span><br><span class="line">git add [dir]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加当前目录下的所有文件</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前文件的修改情况，-s 参数获得简短结果</span></span><br><span class="line">git status -s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示指定文件在暂存区和工作区的差异</span></span><br><span class="line">git diff [file]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示暂存区和上一次提交(commit)的差异</span></span><br><span class="line">git diff --cached [file]</span><br><span class="line">git diff --staged [file]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示两次提交之间的差异</span></span><br><span class="line">git diff [first-branch]...[second-branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交暂存区到本地仓库中，-a 参数设置修改文件后不需要执行 git add 命令，直接来提交</span></span><br><span class="line">git commit -a -m [message]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交暂存区的指定文件到仓库区</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加提交，它可以在不增加一个新的 commit-id 的情况下将新修改的代码追加到前一次的 commit-id 中</span></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--soft 参数用于回退到某个版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD 表示当前版本，HEAD^ 上一个版本，HEAD^^ 上上一个版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者 HEAD~0 表示当前版本，HEAD~1 上一个版本，HEAD^2 上上一个版本</span></span><br><span class="line">git reset [--soft | --mixed | --hard] [HEAD]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件从暂存区和工作区中删除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cached 将文件从暂存区中删除</span></span><br><span class="line">git rm [-f] [--cached] &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移动或重命名一个文件、目录或软连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 如果新文件名已经存在，但还是要重命名它</span></span><br><span class="line">git mv [-f] [file] [newfile]</span><br></pre></td></tr></table></figure>

<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看历史提交记录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--oneline 选项来查看历史记录的简洁的版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--graph 选项，查看历史中什么时候出现了分支、合并</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--reverse 参数来逆向显示所有日志</span></span><br><span class="line">git log [--oneline] [--graph] [--reverse]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以列表形式查看指定文件的历史修改记录</span></span><br><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git remote</td>
<td>远程仓库操作</td>
</tr>
<tr>
<td>git fetch</td>
<td>从远程获取代码库</td>
</tr>
<tr>
<td>git pull</td>
<td>下载远程代码并合并</td>
</tr>
<tr>
<td>git push</td>
<td>上传远程代码并合并</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前的远程库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v | --verbose 列出详细信息</span></span><br><span class="line">git remote [-v | --verbose]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加远程版本库</span></span><br><span class="line">git remote add [shortname] [url]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程仓库</span></span><br><span class="line">git remote rm shortname</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改仓库名</span></span><br><span class="line">git remote rename old_name new_name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支</span></span><br><span class="line">git fetch [alias]</span><br><span class="line">git merge [alias]/[branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程获取代码并合并本地的版本</span></span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从将本地的分支版本上传到远程并合并</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果本地分支名与远程分支名相同，则可以省略冒号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--force 如果本地版本与远程版本有差异，但又要强制推送使用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--delete 删除主机的分支</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push --force origin master</span><br><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-b 创建新分支并立即切换到该分支下</span></span><br><span class="line">git branch -b 分支名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git checkout 分支名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分支</span></span><br><span class="line">git check -d 分支名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并，将分支合并到主分支</span></span><br><span class="line">git merge</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并冲突，查看</span></span><br><span class="line">cat runoob.php</span><br></pre></td></tr></table></figure>

<p>rebase<br>建议：合并记录不要合并已经提交到仓库的记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">整合提交记录，最近3条</span></span><br><span class="line">git rebase -i HEAD-3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 自定义修改美化</title>
    <url>/2022/10/29/Hexo-Custom/</url>
    <content><![CDATA[<h2 id="代码块行数据过长不自动换行显示问题"><a href="#代码块行数据过长不自动换行显示问题" class="headerlink" title="代码块行数据过长不自动换行显示问题"></a>代码块行数据过长不自动换行显示问题</h2><p>修改主题下的 css 文件中的代码块设置，添加如下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$<span class="selector-tag">code</span>-block</span><br><span class="line">  <span class="comment">/*元素内的空白保留，并允许换行*/</span></span><br><span class="line">  <span class="attribute">white-space</span>: pre-wrap <span class="meta">!important</span>;</span><br><span class="line">  <span class="comment">/*是否允许在单词内断句*/</span></span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word <span class="meta">!important</span>;</span><br><span class="line">  <span class="comment">/*强调怎么样断句*/</span></span><br><span class="line">  <span class="comment">/*word-break: break-all !important;*/</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!Too Long!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="修改作者头像"><a href="#修改作者头像" class="headerlink" title="修改作者头像"></a>修改作者头像</h2><p>修改主题配置文件 _config.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Avatar (頭像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">./pics/avatar.jpg</span> <span class="comment"># 图片路径</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网站</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 配置</title>
    <url>/2022/10/28/Hexo-Configuration/</url>
    <content><![CDATA[<p>官方文档 <strong>速度太慢</strong>，复制一份记录下。<br>官方文档：<a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a></p>
<p>您可以在 _config.yml 中修改大部分的配置。</p>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>title</code></td>
<td>网站标题</td>
</tr>
<tr>
<td><code>subtitle</code></td>
<td>网站副标题</td>
</tr>
<tr>
<td><code>description</code></td>
<td>网站描述</td>
</tr>
<tr>
<td><code>keywords</code></td>
<td>网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td><code>author</code></td>
<td>您的名字</td>
</tr>
<tr>
<td><code>language</code></td>
<td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td><code>timezone</code></td>
<td>网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>url</code></td>
<td>网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td>
<td></td>
</tr>
<tr>
<td><code>root</code></td>
<td>网站根目录</td>
<td><code>url&#39;s pathname</code></td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td>
<td><code>:year/:month/:day/:title/</code></td>
</tr>
<tr>
<td><code>permalink_defaults</code></td>
<td>永久链接中各部分的默认值</td>
<td></td>
</tr>
<tr>
<td><code>pretty_urls</code></td>
<td>改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td>
<td></td>
</tr>
<tr>
<td><code>pretty_urls.trailing_index</code></td>
<td>是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>pretty_urls.trailing_html</code></td>
<td>是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td>
<td><code>true</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>网站存放在子目录</strong></p>
<p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 此时页面的永久链接会变为 http://example.com/foo/bar/</span></span><br></pre></td></tr></table></figure>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>source_dir</code></td>
<td>资源文件夹，这个文件夹用来存放内容。</td>
<td><code>source</code></td>
</tr>
<tr>
<td><code>public_dir</code></td>
<td>公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td><code>public</code></td>
</tr>
<tr>
<td><code>tag_dir</code></td>
<td>标签文件夹</td>
<td><code>tags</code></td>
</tr>
<tr>
<td><code>archive_dir</code></td>
<td>归档文件夹</td>
<td><code>archives</code></td>
</tr>
<tr>
<td><code>category_dir</code></td>
<td>分类文件夹</td>
<td><code>categories</code></td>
</tr>
<tr>
<td><code>code_dir</code></td>
<td>Include code 文件夹，<code>source_dir</code> 下的子目录</td>
<td><code>downloads/code</code></td>
</tr>
<tr>
<td><code>i18n_dir</code></td>
<td>国际化（i18n）文件夹</td>
<td><code>:lang</code></td>
</tr>
<tr>
<td><code>skip_render</code></td>
<td>跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td>
<td></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">&quot;mypage/**/*&quot;</span></span><br><span class="line"><span class="comment"># 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录</span></span><br><span class="line"><span class="comment"># 你也可以用这种方法来跳过对指定文章文件的渲染</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">&quot;_posts/test-post.md&quot;</span></span><br><span class="line"><span class="comment"># 这将会忽略对 &#x27;test-post.md&#x27; 的渲染</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p>
</blockquote>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>new_post_name</code></td>
<td>新文章的文件名称</td>
<td>:title.md</td>
</tr>
<tr>
<td><code>default_layout</code></td>
<td>预设布局</td>
<td>post</td>
</tr>
<tr>
<td><code>auto_spacing</code></td>
<td>在中文和英文之间加入空格</td>
<td>false</td>
</tr>
<tr>
<td><code>titlecase</code></td>
<td>把标题转换为 title case</td>
<td>false</td>
</tr>
<tr>
<td><code>external_link</code></td>
<td>在新标签中打开链接</td>
<td>true</td>
</tr>
<tr>
<td><code>external_link.enable</code></td>
<td>在新标签中打开链接</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>external_link.field</code></td>
<td>对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td>
<td><code>site</code></td>
</tr>
<tr>
<td><code>external_link.exclude</code></td>
<td>需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td>
<td><code>[]</code></td>
</tr>
<tr>
<td><code>filename_case</code></td>
<td>把文件名称转换为 (1) 小写或 (2) 大写</td>
<td>0</td>
</tr>
<tr>
<td><code>render_drafts</code></td>
<td>显示草稿</td>
<td>false</td>
</tr>
<tr>
<td><code>post_asset_folder</code></td>
<td>启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td>
<td>false</td>
</tr>
<tr>
<td><code>relative_link</code></td>
<td>把链接改为与根目录的相对位址</td>
<td>false</td>
</tr>
<tr>
<td><code>future</code></td>
<td>显示未来的文章</td>
<td>true</td>
</tr>
<tr>
<td><code>highlight</code></td>
<td>代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td>
<td></td>
</tr>
<tr>
<td><code>prismjs</code></td>
<td>代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>相对地址</strong></p>
<p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
</blockquote>
<h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>default_category</code></td>
<td>默认分类</td>
<td><code>uncategorized</code></td>
</tr>
<tr>
<td><code>category_map</code></td>
<td>分类别名</td>
<td></td>
</tr>
<tr>
<td><code>tag_map</code></td>
<td>标签别名</td>
<td></td>
</tr>
</tbody></table>
<h2 id="日期-x2F-时间格式"><a href="#日期-x2F-时间格式" class="headerlink" title="日期 &#x2F; 时间格式"></a>日期 &#x2F; 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>date_format</code></td>
<td>日期格式</td>
<td><code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td><code>time_format</code></td>
<td>时间格式</td>
<td><code>HH:mm:ss</code></td>
</tr>
<tr>
<td><code>updated_option</code></td>
<td>当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td>
<td><code>mtime</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>updated_option</strong></p>
<p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p>
<ul>
<li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li>
<li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li>
<li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li>
</ul>
<p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p>
</blockquote>
<p><code>use_date_for_updated</code> | 启用以后，如果 Front Matter 中没有指定 <code>updated</code>， <a href="https://hexo.io/zh-cn/docs/configuration"><code>post.updated</code></a> 将会使用 <code>date</code> 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | <code>true</code></p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>per_page</code></td>
<td>每页显示的文章量 (0 &#x3D; 关闭分页功能)</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>pagination_dir</code></td>
<td>分页目录</td>
<td><code>page</code></td>
</tr>
</tbody></table>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>theme</code></td>
<td>当前主题名称。值为<code>false</code>时禁用主题</td>
</tr>
<tr>
<td><code>theme_config</code></td>
<td>主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td>
</tr>
<tr>
<td><code>deploy</code></td>
<td>部署部分的设置</td>
</tr>
<tr>
<td><code>meta_generator</code></td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td>
</tr>
</tbody></table>
<h3 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h3><p>在 Hexo 配置文件中，通过设置 include&#x2F;exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p>
<p><code>include</code> 和 <code>exclude</code> 选项只会应用到 <code>source/</code> ，而 <code>ignore</code> 选项会应用到所有文件夹.</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>include</code></td>
<td>Hexo 默认会不包括 <code>source/</code> 下的文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td>
</tr>
<tr>
<td><code>exclude</code></td>
<td>Hexo 不包括 <code>source/</code> 下的这些文件和目录</td>
</tr>
<tr>
<td><code>ignore</code></td>
<td>Hexo 会忽略整个 Hexo 项目下的这些文件夹或文件</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理或不处理目录或文件</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;.nojekyll&quot;</span></span><br><span class="line">  <span class="comment"># 处理 &#x27;source/css/_typing.css&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;css/_typing.css&quot;</span></span><br><span class="line">  <span class="comment"># 处理 &#x27;source/_css/&#x27; 中的任何文件，但不包括子目录及其其中的文件。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;_css/*&quot;</span></span><br><span class="line">  <span class="comment"># 处理 &#x27;source/_css/&#x27; 中的任何文件和子目录下的任何文件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;_css/**/*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line">  <span class="comment"># 不处理 &#x27;source/js/test.js&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;js/test.js&quot;</span></span><br><span class="line">  <span class="comment"># 不处理 &#x27;source/js/&#x27; 中的文件、但包括子目录下的所有目录和文件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;js/*&quot;</span></span><br><span class="line">  <span class="comment"># 不处理 &#x27;source/js/&#x27; 中的文件和子目录下的任何文件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;js/**/*&quot;</span></span><br><span class="line">  <span class="comment"># 不处理 &#x27;source/js/&#x27; 目录下的所有文件名以 &#x27;test&#x27; 开头的文件，但包括其它文件和子目录下的单文件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;js/test*&quot;</span></span><br><span class="line">  <span class="comment"># 不处理 &#x27;source/js/&#x27; 及其子目录中任何以 &#x27;test&#x27; 开头的文件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;js/**/test*&quot;</span></span><br><span class="line">  <span class="comment"># 不要用 exclude 来忽略 &#x27;source/_posts/&#x27; 中的文件。你应该使用 &#x27;skip_render&#x27;，或者在要忽略的文件的文件名之前加一个下划线 &#x27;_&#x27;</span></span><br><span class="line">  <span class="comment"># 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line">  <span class="comment"># 忽略任何一个名叫 &#x27;foo&#x27; 的文件夹</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;**/foo&quot;</span></span><br><span class="line">  <span class="comment"># 只忽略 &#x27;themes/&#x27; 下的 &#x27;foo&#x27; 文件夹</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;**/themes/*/foo&quot;</span></span><br><span class="line">  <span class="comment"># 对 &#x27;themes/&#x27; 目录下的每个文件夹中忽略名叫 &#x27;foo&#x27; 的子文件夹</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;**/themes/**/foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>列表中的每一项都必须用单引号或双引号包裹起来。</p>
<p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p>
<h3 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h3><p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用 &#x27;custom.yml&#x27; 代替 &#x27;_config.yml&#x27;</span></span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 &#x27;custom.yml&#x27; 和 &#x27;custom2.json&#x27;，优先使用 &#x27;custom3.yml&#x27;，然后是 &#x27;custom2.json&#x27;</span></span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure>

<p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p>
<h3 id="使用代替主题配置文件"><a href="#使用代替主题配置文件" class="headerlink" title="使用代替主题配置文件"></a>使用代替主题配置文件</h3><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p>
<p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p>
<p><strong>配置文件中的 <code>theme_config</code></strong></p>
<blockquote>
<p>该特性自 Hexo 2.8.2 起提供</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">&quot;my-theme&quot;</span></span><br><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">bio:</span> <span class="string">&quot;My awesome bio&quot;</span></span><br><span class="line">  <span class="attr">foo:</span></span><br><span class="line">    <span class="attr">bar:</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># themes/my-theme/_config.yml</span></span><br><span class="line"><span class="attr">bio:</span> <span class="string">&quot;Some generic bio&quot;</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">&quot;a-cool-image.png&quot;</span></span><br><span class="line">  <span class="attr">foo:</span></span><br><span class="line">    <span class="attr">baz:</span> <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">bio:</span> <span class="string">&quot;My awesome bio&quot;</span>,</span><br><span class="line">  <span class="attr">logo:</span> <span class="string">&quot;a-cool-image.png&quot;</span>,</span><br><span class="line">  <span class="attr">foo:</span> &#123;</span><br><span class="line">    <span class="attr">bar:</span> <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    <span class="attr">baz:</span> <span class="string">&quot;b&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p>
<blockquote>
<p>该特性自 Hexo 5.0.0 起提供</p>
</blockquote>
<p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">&quot;my-theme&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.my-theme.yml</span></span><br><span class="line"><span class="attr">bio:</span> <span class="string">&quot;My awesome bio&quot;</span></span><br><span class="line"><span class="attr">foo:</span>  </span><br><span class="line">    <span class="attr">bar:</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># themes/my-theme/_config.yml</span></span><br><span class="line"><span class="attr">bio:</span> <span class="string">&quot;Some generic bio&quot;</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">&quot;a-cool-image.png&quot;</span>  </span><br><span class="line">    <span class="attr">foo:</span>    </span><br><span class="line">        <span class="attr">baz:</span> <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="attr">bio:</span> <span class="string">&quot;My awesome bio&quot;</span>,  </span><br><span class="line">    <span class="attr">logo:</span> <span class="string">&quot;a-cool-image.png&quot;</span>,  </span><br><span class="line">    <span class="attr">foo:</span> &#123;    </span><br><span class="line">        <span class="attr">bar:</span> <span class="string">&quot;a&quot;</span>,    </span><br><span class="line">        <span class="attr">baz:</span> <span class="string">&quot;b&quot;</span>  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p>
</blockquote>
]]></content>
      <categories>
        <category>网站</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 安装</title>
    <url>/2022/10/27/Hexo-Insall/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载并安装-node-js"><a href="#下载并安装-node-js" class="headerlink" title="下载并安装 node.js"></a>下载并安装 node.js</h3><p>前往官网下载 nodes.js: <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看安装是否成功</span></span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>

<h3 id="设置-npm-淘宝镜像站"><a href="#设置-npm-淘宝镜像站" class="headerlink" title="设置 npm 淘宝镜像站"></a>设置 npm 淘宝镜像站</h3><p><code>npm config set registry &quot;https://registry.npm.taobao.org&quot;</code></p>
<h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo</span></span><br><span class="line">$ npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化博客项目，不填写项目名会初始化当前目录，项目名对应文件夹不存在，会自动创建</span></span><br><span class="line">$ hexo init 项目名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到项目目录下</span></span><br><span class="line">$ <span class="built_in">cd</span> 项目路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 hexo 扩展插件</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>查看网页效果：<a href="http://localhost:4000/">http://localhost:4000/</a></p>
]]></content>
      <categories>
        <category>网站</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2022/10/28/Markdown/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><code>#</code>+空格+标题名，几个<code>#</code>代表几级标题，最多6级。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code># Heading level 1</code></td>
<td><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td>
<td><h1>Heading level 1</h1></td>
</tr>
<tr>
<td><code>## Heading level 2</code></td>
<td><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td>
<td><h2>Heading level 2</h2></td>
</tr>
<tr>
<td><code>### Heading level 3</code></td>
<td><code>&lt;h3&gt;Heading level 3&lt;/h3&gt;</code></td>
<td><h3>Heading level 3</h3></td>
</tr>
<tr>
<td><code>#### Heading level 4</code></td>
<td><code>&lt;h4&gt;Heading level 4&lt;/h4&gt;</code></td>
<td><h4>Heading level 4</h4></td>
</tr>
<tr>
<td><code>##### Heading level 5</code></td>
<td><code>&lt;h5&gt;Heading level 5&lt;/h5&gt;</code></td>
<td><h5>Heading level 5</h5></td>
</tr>
<tr>
<td><code>###### Heading level 6</code></td>
<td><code>&lt;h6&gt;Heading level 6&lt;/h6&gt;</code></td>
<td><h6>Heading level 6</h6></td>
</tr>
</tbody></table>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)。</p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td><code>I just love **bold text**.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
<td>粗体</td>
</tr>
<tr>
<td><code>I just love *bold text*.</code></td>
<td><code>I just love &lt;em&gt;bold text&lt;/em&gt;.</code></td>
<td>I just love <em>bold text</em>.</td>
<td>斜体</td>
</tr>
<tr>
<td><code>I just love ***bold text***.</code></td>
<td><code>Love&lt;strong&gt;&lt;em&gt;is&lt;/em&gt;&lt;/strong&gt;bold</code></td>
<td>I just love <em><strong>bold text</strong></em>.</td>
<td>粗体和斜体</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>单个块引用：在段落前添加一个 <code>&gt;</code> 符号:<br><code>&gt; 段落内容</code><br>效果：</p>
<blockquote>
<p>段落内容</p>
</blockquote>
<p>多个段落块引用：在段落和段落之间的空白行都添加一个 <code>&gt;</code> 符号:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 段落1</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 段落2</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>段落1</p>
<p>段落2</p>
</blockquote>
<p>嵌套引用</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 段落1</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;&gt; 嵌套1</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; - 列表1</span></span><br><span class="line"><span class="quote">&gt; - 列表2</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>段落1</p>
<blockquote>
<p>嵌套1</p>
</blockquote>
<ul>
<li>列表1</li>
<li>列表2</li>
</ul>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>有序列表:请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。<br>无序列表:请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序1</span><br><span class="line"><span class="bullet">1.</span> 有序2</span><br><span class="line"><span class="bullet">8.</span> 有序3</span><br><span class="line"><span class="bullet">3.</span> 有序4</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 无序1</span><br><span class="line"><span class="bullet">-</span> 无序2</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ol>
<li>有序1</li>
<li>有序2</li>
<li>有序3</li>
<li>有序4</li>
</ol>
<ul>
<li>无序1</li>
<li>无序2</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>要将单词或短语表示为代码，请将其包裹在反引号<code>`</code>中。<br>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(&#96;&#96;)中。</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p>
<p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。<br><code>&lt;https://markdown.com.cn&gt;</code></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><code>![图片alt](图片链接 &quot;图片title&quot;)</code></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 标题1 | 标题2|</span><br><span class="line">| --- | --- |</span><br><span class="line">| A   | B   |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>标题1</th>
<th>标题2</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>B</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/10/31/Regex/</url>
    <content><![CDATA[<h2 id="C-正则表达式库-std-regex"><a href="#C-正则表达式库-std-regex" class="headerlink" title="C++正则表达式库 std::regex"></a>C++正则表达式库 std::regex</h2><p>std::regex 是 C++ 用来表示「正则表达式」（regular expression）的库，于 C++11 加入，它是 class std::basic_regex&lt;&gt; 针对 char 类型的一个特化，还有一个针对 wchar_t 类型的特化为 std::wregex。</p>
<h3 id="正则文法（regex-syntaxes）"><a href="#正则文法（regex-syntaxes）" class="headerlink" title="正则文法（regex syntaxes）"></a>正则文法（regex syntaxes）</h3><p>std::regex 默认使用是 ECMAScript 文法，这种文法比较好用，且威力强大，常用符号的意义如下：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配行的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配行的结尾</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配 [] 中的任意一个字符</td>
</tr>
<tr>
<td>(…)</td>
<td>设定分组</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>\d 取反</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母 [a-z]，数字，下划线</td>
</tr>
<tr>
<td>\W</td>
<td>\w 取反</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格</td>
</tr>
<tr>
<td>\S</td>
<td>\s 取反</td>
</tr>
<tr>
<td>+</td>
<td>前面的元素重复 1 次或多次</td>
</tr>
<tr>
<td>*</td>
<td>前面的元素重复任意次</td>
</tr>
<tr>
<td>?</td>
<td>前面的元素重复 0 次或 1 次</td>
</tr>
<tr>
<td>{n}</td>
<td>前面的元素重复 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>前面的元素重复至少 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>前面的元素重复至少 n 次，至多 m 次</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或</td>
</tr>
</tbody></table>
<h4 id="匹配（Match）"><a href="#匹配（Match）" class="headerlink" title="匹配（Match）"></a>匹配（Match）</h4><p>字符串处理常用的一个操作是「匹配」，即字符串和规则恰好对应，而用于匹配的函数为 std::regex_match()，它是个函数模板，我们直接来看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;.*&gt;.*&lt;/.*&gt;&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">bool</span> ret = std::<span class="built_in">regex_match</span>(<span class="string">&quot;&lt;html&gt;value&lt;/html&gt;&quot;</span>, reg);</span><br><span class="line"><span class="built_in">assert</span>(ret);</span><br><span class="line"></span><br><span class="line">ret = std::<span class="built_in">regex_match</span>(<span class="string">&quot;&lt;xml&gt;value&lt;xml&gt;&quot;</span>, reg);</span><br><span class="line"><span class="built_in">assert</span>(!ret);</span><br></pre></td></tr></table></figure>

<h4 id="搜索（Search）"><a href="#搜索（Search）" class="headerlink" title="搜索（Search）"></a>搜索（Search）</h4><p>「搜索」与「匹配」非常相像，其对应的函数为 std::regex_search，也是个函数模板，用法和 regex_match 一样，不同之处在于「搜索」只要字符串中有目标出现就会返回，而非完全「匹配」。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line">std::cmatch m;</span><br><span class="line"><span class="keyword">auto</span> ret = std::<span class="built_in">regex_search</span>(<span class="string">&quot;123&lt;xml&gt;value&lt;/xml&gt;456&quot;</span>, m, reg);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; elem : m)</span><br><span class="line">		std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分词（Tokenize）"><a href="#分词（Tokenize）" class="headerlink" title="分词（Tokenize）"></a>分词（Tokenize）</h4><p>还有一种操作叫做「切割」，例如有一组数据保存着许多邮箱账号，并以逗号分隔，那就可以指定以逗号为分割符来切割这些内容，从而得到每个账号。</p>
<p>而在 C++的正则中，把这种操作称为 Tokenize，用模板类 regex_token_iterator&lt;&gt;提供分词迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">mail</span><span class="params">(<span class="string">&quot;123@qq.vip.com,456@gmail.com,789@163.com,abcd@my.com&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::sregex_token_iterator <span class="title">pos</span><span class="params">(mail.begin(), mail.end(), reg, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(pos) end;</span><br><span class="line"><span class="keyword">for</span> (; pos != end; ++pos)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; pos-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="替换（Replace）"><a href="#替换（Replace）" class="headerlink" title="替换（Replace）"></a>替换（Replace）</h4><p>最后一种操作称为「替换」，即将正则表达式内容替换为指定内容，regex 库用模板函数 std::regex_replace 提供「替换」操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;he...ll..o, worl..d!&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;\\.&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// output: hello, world!</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">regex_replace</span>(data, reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;001-Neo,002-Lucia&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;(\\d+)-(\\w+)&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// output: 001 name=Neo,002 name=Lucia</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">regex_replace</span>(data, reg, <span class="string">&quot;$1 name=$2&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2022/10/28/Sort-Algorithm/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img src="/./pics/Sort-Algorithm.png" alt="排序算法时间空间复杂的比较" title="排序算法时间空间复杂的比较"></p>
<p><img src="/./pics/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="排序算法" title="排序算法"></p>
<ul>
<li><a href="/2022/10/28/Sort-Bubble/" title="冒泡排序">冒泡排序</a></li>
<li><a href="/2022/10/28/Sort-Selection/" title="选择排序">选择排序</a></li>
<li><a href="/2022/10/28/Sort-Insertion/" title="插入排序">插入排序</a></li>
<li><a href="/2022/10/28/Sort-Shell/" title="希尔排序">希尔排序</a></li>
<li><a href="/2022/10/28/Sort-Merging/" title="归并排序">归并排序</a></li>
<li><a href="/2022/10/28/Sort-Quick/" title="快速排序">快速排序</a></li>
<li><a href="/2022/10/28/Sort-Heap/" title="堆排序">堆排序</a></li>
<li><a href="/2022/10/28/Sort-Counting/" title="计数排序">计数排序</a></li>
<li><a href="/2022/10/28/Sort-Bucket/" title="桶排序">桶排序</a></li>
<li><a href="/2022/10/28/Sort-Radix/" title="基数排序">基数排序</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2022/10/28/Sort-Bubble/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>将最值<strong>一步一步冒出</strong>末端</p>
<ul>
<li>从头到尾遍历，<strong>比较相邻的两个元素</strong>，如果<strong>顺序是逆序</strong>，<strong>交换</strong>两个元素。</li>
<li>每次遍历会将<strong>遍历区间中最值</strong>移动到<strong>遍历区间的末端</strong>，末端变为有序。</li>
<li>遍历区间会随着遍历次数的增加而减小。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQBubbleSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> bChange = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (vtData.<span class="built_in">size</span>() - <span class="number">1</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (vtData.<span class="built_in">size</span>() - <span class="number">1</span> - i); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vtData[j] &gt; vtData[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(vtData[j], vtData[j+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                bChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! bChange)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/2022/10/28/Sort-Bucket/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>分配容量为 b 的 n 个桶</p>
<ul>
<li>容量为 b 的 (maxVal - minVal + b) &#x2F; b 个桶</li>
<li>将数据按照 (val - minVal) &#x2F; b 放入桶中</li>
<li>遍历多个桶，每个桶用其它排序方法进行桶内排序</li>
<li>将已经排好序的桶内数据存放到输出数组中</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQBucketSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vtData.<span class="built_in">size</span>() &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> bRet;</span><br><span class="line"></span><br><span class="line">    T maxVal = <span class="number">0</span>;</span><br><span class="line">    T minVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vtData.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        maxVal = std::<span class="built_in">max</span>(maxVal, vtData[i]);</span><br><span class="line">        minVal = std::<span class="built_in">min</span>(minVal, vtData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>; <span class="comment">// 每个桶的容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = (maxVal - minVal + b) / b;</span><br><span class="line">    std::vector&lt;std::list&lt;T&gt;&gt; <span class="built_in">buckets</span>(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : vtData) &#123;</span><br><span class="line">        <span class="type">int</span> index = (val - minVal) / b;</span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 桶内排序与收集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : buckets) &#123;</span><br><span class="line">        <span class="comment">// 使用其他排序方法进行桶内排序</span></span><br><span class="line">        l.<span class="built_in">sort</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : l)</span><br><span class="line">            vtData[index++] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2022/10/28/Sort-Counting/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>统计数据出现的次数，再遍历统计数组将数据填入输出数组中</p>
<ul>
<li>获取最大值和最小值，分配空间为最大值和最小值差值大小的数组</li>
<li>遍历统计数据出现的次数，将数据填入 i-min 中</li>
<li>从头到尾遍历，将统计数据整理成记录元素位置数组</li>
<li>从尾到头遍历，将统计数组中的位置存放数据</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQCountingSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vtData.<span class="built_in">size</span>() &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> bRet;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (vtData.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    T max = <span class="number">0</span>;</span><br><span class="line">    T min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i : vtData)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max)</span><br><span class="line">            max = i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; min)</span><br><span class="line">            min = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配大小为最大值和最小值差值的数组用于计数</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vtCount</span><span class="params">(max - min + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">vtOut</span><span class="params">(vtData.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数据出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vtData.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vtCount[vtData[i]-min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在输出数组中给每个桶分配对应个数的存放位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; vtCount.<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        vtCount[j] += vtCount[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将数据填入输出数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = vtData.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        vtOut[--vtCount[vtData[j]]] = vtData[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vtData = vtOut;</span><br><span class="line"></span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2022/10/28/Sort-Insertion/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>原理：遍历数据，将数据<strong>插入有序的数组</strong>中</p>
<ul>
<li>第一个元素为<strong>有序数组</strong>，将从第二个元素开始的无序元素<strong>插入到有序数组</strong>中</li>
<li>在有序数组中用<strong>折半查找</strong>方法查找插入位置下标</li>
<li>将下标位置的<strong>数据往后移</strong>，再将元素放到下标位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQInsertionSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 个数据时，是一个有序表，所以从第 2 个元素开始插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vtData.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = vtData[i];</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 折半查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nLow = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> nHight = i;</span><br><span class="line">            <span class="keyword">while</span> (nLow &lt; nHight)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nPos = (nLow + nHight) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (vtData[nPos] &lt; tmp)</span><br><span class="line">                    nLow = nPos + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nHight = nPos - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 nHight 元素往后移</span></span><br><span class="line">            <span class="keyword">for</span> (j = (i - <span class="number">1</span>); j &gt;= nHight; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                vtData[j+<span class="number">1</span>] = vtData[j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vtData[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2022/10/28/Sort-Heap/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<p>将数据组成<strong>一个堆数据结构</strong></p>
<ul>
<li>从<strong>最后一个父节点</strong>开始将数据<strong>调整成堆结构</strong>，子节点为 i*2+1。</li>
<li>因为组成堆结构，<strong>第一个元素是堆顶</strong>，是<strong>最值</strong>。将<strong>第一个元素和最后一个元素</strong>互换，最后一个元素元素脱离堆，元素数量 -1 <strong>从新调整堆</strong>。</li>
</ul>
<p>堆的数据分布：<br>A&#x3D;0|B&#x3D;A<em>2+1|C&#x3D;A</em>2+2|D&#x3D;B<em>2+1|E&#x3D;B</em>2+2|F&#x3D;C<em>2+1|G&#x3D;C</em>2+2</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQHeapSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 初始化堆排序</span></span><br><span class="line">    <span class="built_in">CreateHeap</span>(vtData);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nSize = vtData.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将符合排序的根节点和最后一个子节点数据，vtData[i] 为已经排好序节点</span></span><br><span class="line">        std::<span class="built_in">swap</span>(vtData[i], vtData[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少一个数据 vtData[i]，重新调整堆</span></span><br><span class="line">        <span class="built_in">HeapAdjust</span>(vtData, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CQHeapSort&lt;T&gt;::<span class="built_in">CreateHeap</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nSize = vtData.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 从最后一个父节点开始调整。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (nSize / <span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(vtData, i, nSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CQHeapSort&lt;T&gt;::<span class="built_in">HeapAdjust</span>(std::vector&lt;T&gt;&amp; vtData, <span class="type">int</span> index, <span class="type">int</span> nSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nDad = index;</span><br><span class="line">    <span class="type">int</span> nSon = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nSon &lt; nSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取最大子节点下标</span></span><br><span class="line">        <span class="keyword">if</span> (((nSon+<span class="number">1</span>) &lt; nSize) &amp;&amp; (vtData[nSon] &lt; vtData[nSon + <span class="number">1</span>]))</span><br><span class="line">            nSon ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建堆后，子节点后面部分已经是有序的，如果父节点没有变化，堆已经调整完成。</span></span><br><span class="line">        <span class="keyword">if</span> (vtData[nDad] &gt;= vtData[nSon])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整父子节点数据</span></span><br><span class="line">        std::<span class="built_in">swap</span>(vtData[nDad], vtData[nSon]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据发生变化，需要继续调整子堆的数据</span></span><br><span class="line">        nDad = nSon;</span><br><span class="line">        nSon = nSon * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2022/10/28/Sort-Merging/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>原理：将数据<strong>分割成 n 个有序队列</strong>后，再将有序队列<strong>合并</strong>成一个队列</p>
<ul>
<li>将队列<strong>分割成 n 个队列</strong>，直到一个队列只有一个元素，<strong>队列为有序队列</strong>；</li>
<li>将分割的队列合并成一个新的有序队列，直到将所有队列合并成一个。</li>
</ul>
<p>两种实现方法：</p>
<ul>
<li>递归法</li>
<li>迭代法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQMergingSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="comment">// MergeSort(vtData, 0, vtData.size() - 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代实现</span></span><br><span class="line">    <span class="comment">// 按照步长 1 将素组分割成 nLen 份组合，再加宽步长继续组合</span></span><br><span class="line">    <span class="type">int</span> nLen = vtData.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nStep = <span class="number">1</span>; nStep &lt; nLen; nStep *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nStart = <span class="number">0</span>; nStart &lt; nLen; nStart += (nStep * <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Merge</span>(vtData, nStart, std::<span class="built_in">min</span>(nStart+nStep<span class="number">-1</span>, nLen), std::<span class="built_in">min</span>(nStart+nStep+nStep<span class="number">-1</span>, nLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CQMergingSort&lt;T&gt;::<span class="built_in">MergeSort</span>(std::vector&lt;T&gt;&amp; vtData, <span class="type">int</span> nStart, <span class="type">int</span> nEnd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nStart &gt;= nEnd)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nMid = (nStart + nEnd) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(vtData, nStart, nMid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(vtData, nMid + <span class="number">1</span>, nEnd);</span><br><span class="line">    <span class="built_in">Merge</span>(vtData, nStart, nMid, nEnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CQMergingSort&lt;T&gt;::<span class="built_in">Merge</span>(std::vector&lt;T&gt;&amp; vtData, <span class="type">int</span> nStart, <span class="type">int</span> nMid, <span class="type">int</span> nEnd)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;T&gt; vtTmp;</span><br><span class="line">    vtTmp.<span class="built_in">reserve</span>(nEnd - nStart + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nLow = nStart;</span><br><span class="line">    <span class="type">int</span> nHight = nMid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((nLow &lt;= nMid) &amp;&amp; (nHight &lt;= nEnd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vtData[nLow] &lt;= vtData[nHight])</span><br><span class="line">        &#123;</span><br><span class="line">            vtTmp.<span class="built_in">push_back</span>(vtData[nLow]);</span><br><span class="line">            nLow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vtTmp.<span class="built_in">push_back</span>(vtData[nHight]);</span><br><span class="line">            nHight ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (nLow &lt;= nMid)</span><br><span class="line">    &#123;</span><br><span class="line">        vtTmp.<span class="built_in">push_back</span>(vtData[nLow]);</span><br><span class="line">        nLow ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nHight &lt;= nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        vtTmp.<span class="built_in">push_back</span>(vtData[nHight]);</span><br><span class="line">        nHight ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vtTmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vtData[nStart + i] = vtTmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2022/10/28/Sort-Quick/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>原理：比基数大的放右边，小的放左边</p>
<ul>
<li>取一个基数，将大于基数的放到左边，小于基数的放到右边，返回最终基数的下标</li>
<li>递归对基数左边区间做第一步的操作，直到区间只剩一个元素位为止</li>
<li>基数右边区间也按照第二部的操作执行</li>
</ul>
<blockquote>
<p>优化：</p>
<ul>
<li>三数取中</li>
<li>挖坑法，双指针填坑</li>
<li>小于阈值改用插入排序</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQQuickSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (vtData.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(vtData, <span class="number">0</span>, vtData.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CQQuickSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData, <span class="type">int</span> nLow, <span class="type">int</span> nHight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以设置阈值,当区间小于阈值时,改用插入排序,减小递归深度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLow &lt; nHight)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(vtData, nLow, nHight);</span><br><span class="line">        <span class="built_in">sort</span>(vtData, nLow, (pivot - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">sort</span>(vtData, (pivot + <span class="number">1</span>), nHight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双边循环</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> CQQuickSort&lt;T&gt;::<span class="built_in">partition</span>(std::vector&lt;T&gt;&amp; vtData, <span class="type">int</span> nLow, <span class="type">int</span> nHight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以使用三数取中的方法获取坑位</span></span><br><span class="line">    <span class="comment">// 坑位</span></span><br><span class="line">    T pivot = vtData[nLow];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nLow &lt; nHight)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取比基准点小的下标</span></span><br><span class="line">        <span class="keyword">while</span> ((nLow &lt; nHight) &amp;&amp; (vtData[nHight] &gt;= pivot))</span><br><span class="line">        &#123;</span><br><span class="line">            nHight --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换比基准点小的,移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (nLow &lt; nHight)</span><br><span class="line">            vtData[nLow++] = vtData[nHight];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取比基准点大的下标</span></span><br><span class="line">        <span class="keyword">while</span> ((nLow &lt; nHight) &amp;&amp; (vtData[nLow] &lt;= pivot))</span><br><span class="line">        &#123;</span><br><span class="line">            nLow ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换比基准点大的，移到右边</span></span><br><span class="line">        <span class="keyword">if</span> (nLow &lt; nHight)</span><br><span class="line">            vtData[nHight--] = vtData[nLow];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vtData[nLow] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nLow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/2022/10/28/Sort-Radix/</url>
    <content><![CDATA[<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>原理：从个位 十位 … 进行分桶，将个位排好序，十位排好序… 最终得到排好序的数组</p>
<ul>
<li>获取最大值有多少位数，从个位开始遍历，十位再百位…</li>
<li>计算位数元素出现的个数</li>
<li>从头到尾遍历，将统计数据整理成记录元素位置数组</li>
<li>从尾到头遍历，将统计数组中的位置存放数据</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQRadixSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求位数</span></span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">MaxBit</span>(vtData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vtData.<span class="built_in">empty</span>() || d &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 遍历位数 个位 -&gt; 十位 -&gt; 百位 ...</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;  <span class="comment">// 位数</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vtRadix</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// 基数容器 0-9</span></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">vtTmp</span><span class="params">(vtData.size())</span></span>;   <span class="comment">// 临时排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 基数容器清零</span></span><br><span class="line">        std::<span class="built_in">fill</span>(vtRadix.<span class="built_in">begin</span>(), vtRadix.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算分配给每个桶的元素个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : vtData)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (val / radix) % <span class="number">10</span>;</span><br><span class="line">            vtRadix[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给每个桶分配对应个数的存放位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vtRadix[j] += vtRadix[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存放到桶中的顺序是倒序，从后往前遍历数据</span></span><br><span class="line">        <span class="keyword">for</span> (j = vtData.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (vtData[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 倒序</span></span><br><span class="line">            vtTmp[--vtRadix[k]] = vtData[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vtData = vtTmp;</span><br><span class="line"></span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2022/10/28/Sort-Shell/</url>
    <content><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>原理：插入排序的优化版本，添加增量将分组进行插入排序</p>
<ul>
<li>第一个 for 循环，增量 数组长度&#x2F;2,直到增量为1结束</li>
<li>第二个 for 循环，区间为增量大小，逐渐增多，直到区间扩大为原数组大小</li>
<li>第三个 for 循环，将区间内的元素，按照增量分组，比较排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQShellSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = vtData.<span class="built_in">size</span>() / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; vtData.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            T tmp = vtData[i];</span><br><span class="line">            <span class="type">int</span> j = i - d;</span><br><span class="line">            <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; (vtData[j] &gt; tmp); j -= d)</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(vtData[j], vtData[j+d]); </span><br><span class="line">            &#125;</span><br><span class="line">            vtData[j+d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress 安装和部署</title>
    <url>/2022/10/27/wordpress-%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网站</category>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>网页</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/2022/10/31/json/</url>
    <content><![CDATA[<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>JSON 语法是 JavaScript 对象表示语法的子集。</p>
<ul>
<li>数据在名称&#x2F;值对中</li>
<li>数据由逗号 , 分隔</li>
<li>使用斜杆来转义 \ 字符</li>
<li>大括号 {} 保存对象</li>
<li>中括号 [] 保存数组，数组可以包含多个对象</li>
</ul>
<h2 id="JSON-值"><a href="#JSON-值" class="headerlink" title="JSON 值"></a>JSON 值</h2><p>JSON 值可以是：</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在中括号中）</li>
<li>对象（在大括号中）</li>
<li>null</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span><span class="number">123</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;float&quot;</span><span class="punctuation">:</span><span class="number">3.14</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;string&quot;</span><span class="punctuation">:</span><span class="string">&quot;Hello World&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;array&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;employees&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;peter&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Anna&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;emample&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://www.emample.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2022/10/28/Sort-Selection/</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>原理：<strong>选择最值</strong>摆放到末端</p>
<ul>
<li>遍历数据，<strong>记录最小&#x2F;最大的数据的下标</strong>，将<strong>最值和末端元素交换</strong>。</li>
<li>遍历区间随着遍历次数增加而减小，末端变为有序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CQSelectionSort&lt;T&gt;::<span class="built_in">sort</span>(std::vector&lt;T&gt;&amp; vtData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最值</span></span><br><span class="line">    <span class="type">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无序区间末端下标</span></span><br><span class="line">    <span class="type">int</span> nLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nRight = vtData.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左往右遍历</span></span><br><span class="line">    <span class="keyword">while</span> (nLeft &lt; nRight)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 最值设置为无序区间两端</span></span><br><span class="line">        minIndex = nLeft;</span><br><span class="line">        maxIndex = nRight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历无序区间，记录最大和最小数据下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = nLeft; j &lt; nRight; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vtData[j] &gt; vtData[maxIndex])</span><br><span class="line">                maxIndex = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vtData[j] &lt; vtData[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最大和最小值位置互换</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == nLeft &amp;&amp; minIndex == nRight)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(vtData[maxIndex], vtData[minIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 最小值移动到最左端</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != nLeft)</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(vtData[nLeft], vtData[minIndex]);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 最大值位置发生改变，更新下标值</span></span><br><span class="line">                <span class="keyword">if</span> (maxIndex == nLeft)</span><br><span class="line">                    maxIndex = minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最大值移动到最右端</span></span><br><span class="line">            <span class="keyword">if</span> (maxIndex != nRight)</span><br><span class="line">                std::<span class="built_in">swap</span>(vtData[nRight], vtData[maxIndex]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nLeft++;</span><br><span class="line">        nRight--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bRet = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
